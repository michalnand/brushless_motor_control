#include <motor_control.h>
#include <device.h>
#include <adc.h>

MotorControl::MotorControl()
{
    
}

void MotorControl::init(AS5600 *encoder, Motor *motor)
{
    this->encoder   = encoder;
    this->motor     = motor;

    this->required_current = 0;
    this->current          = 0;

    //current sense, PA4, adc_ch 4
    Gpio<TGPIOA, 4, GPIO_Mode_AN>  adc_sense;


    torque_pid.init(1.0*16384, 1.0*16384, 0.0*16384, 1, MOTOR_CONTROL_MAX);
} 

MotorControl::~MotorControl()
{

}

/*
    most inner control loop, call it as fast as possible (1kHz..2kHz)
*/
void MotorControl::callback_torque()
{   
    //i     = u/r = (adc*3.3/4096)/0.33
    //uref  = 3.3V, R = 0.33ohm, result in mA
    int32_t adc     = adc_read(ADC_Channel_4);
    int32_t current   = (adc*10000)/4096;

    this->current = current;


    int32_t u = MOTOR_CONTROL_MAX/4;
    this->motor->set_torque(u, 0, rotor_angle); 
    
    rotor_angle = (rotor_angle+1)%4096;
}   

/* 
    state space controller loop, call it in aprox. 200Hz
*/
void MotorControl::callback(int32_t dt_us)
{
    this->encoder->update(dt_us);

    int32_t position    = this->encoder->position;
    int32_t velocity    = this->encoder->angular_velocity;

    //int32_t velocity_req = 4096;
    //this->torque = this->lqr_velocity.step(velocity_req, velocity);

    float position_req = 90;

    //this->torque = MOTOR_CONTROL_MAX*this->lqr_position.step(position_req*DEG_TO_RAD, position*BID_TO_RAD, velocity*BID_TO_RAD);
}